# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateDocument {
  _avg: DocumentAvgAggregate
  _count: DocumentCountAggregate
  _max: DocumentMaxAggregate
  _min: DocumentMinAggregate
  _sum: DocumentSumAggregate
}

type AggregateDocumentContent {
  _count: DocumentContentCountAggregate
  _max: DocumentContentMaxAggregate
  _min: DocumentContentMinAggregate
}

type AggregateEmailDetails {
  _count: EmailDetailsCountAggregate
  _max: EmailDetailsMaxAggregate
  _min: EmailDetailsMinAggregate
}

type AggregateOrganization {
  _count: OrganizationCountAggregate
  _max: OrganizationMaxAggregate
  _min: OrganizationMinAggregate
}

type AggregatePersonnel {
  _count: PersonnelCountAggregate
  _max: PersonnelMaxAggregate
  _min: PersonnelMinAggregate
}

type AggregateTopic {
  _count: TopicCountAggregate
  _max: TopicMaxAggregate
  _min: TopicMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Byte

input BytesNullableFilter {
  equals: Byte
  not: NestedBytesNullableFilter
}

input BytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  not: NestedBytesNullableWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Document {
  _count: DocumentCount
  beginDate: DateTime
  documentContent: DocumentContent
  driveId: String!
  emailDetails: EmailDetails
  endDate: DateTime
  fileName: String!
  id: String!
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  personnel(cursor: PersonnelWhereUniqueInput, distinct: [PersonnelScalarFieldEnum!], orderBy: [PersonnelOrderByWithRelationInput!], skip: Int, take: Int, where: PersonnelWhereInput): [Personnel!]!
  relevanceScore: Int
  sbrId: String!
  summary: String
  topics(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): [Topic!]!
}

type DocumentAvgAggregate {
  pages: Float
  relevanceScore: Float
}

input DocumentAvgOrderByAggregateInput {
  pages: SortOrder
  relevanceScore: SortOrder
}

type DocumentContent {
  document: Document!
  documentId: String!
  file: Byte
  id: String!
  text: String
}

type DocumentContentCountAggregate {
  _all: Int!
  documentId: Int!
  file: Int!
  id: Int!
  text: Int!
}

input DocumentContentCountOrderByAggregateInput {
  documentId: SortOrder
  file: SortOrder
  id: SortOrder
  text: SortOrder
}

input DocumentContentCreateInput {
  document: DocumentCreateNestedOneWithoutDocumentContentInput!
  file: Byte
  id: String
  text: String
}

input DocumentContentCreateManyInput {
  documentId: String!
  file: Byte
  id: String
  text: String
}

input DocumentContentCreateNestedOneWithoutDocumentInput {
  connect: DocumentContentWhereUniqueInput
  connectOrCreate: DocumentContentCreateOrConnectWithoutDocumentInput
  create: DocumentContentCreateWithoutDocumentInput
}

input DocumentContentCreateOrConnectWithoutDocumentInput {
  create: DocumentContentCreateWithoutDocumentInput!
  where: DocumentContentWhereUniqueInput!
}

input DocumentContentCreateWithoutDocumentInput {
  file: Byte
  id: String
  text: String
}

type DocumentContentGroupBy {
  _count: DocumentContentCountAggregate
  _max: DocumentContentMaxAggregate
  _min: DocumentContentMinAggregate
  documentId: String!
  file: Byte
  id: String!
  text: String
}

type DocumentContentMaxAggregate {
  documentId: String
  file: Byte
  id: String
  text: String
}

input DocumentContentMaxOrderByAggregateInput {
  documentId: SortOrder
  file: SortOrder
  id: SortOrder
  text: SortOrder
}

type DocumentContentMinAggregate {
  documentId: String
  file: Byte
  id: String
  text: String
}

input DocumentContentMinOrderByAggregateInput {
  documentId: SortOrder
  file: SortOrder
  id: SortOrder
  text: SortOrder
}

input DocumentContentOrderByWithAggregationInput {
  _count: DocumentContentCountOrderByAggregateInput
  _max: DocumentContentMaxOrderByAggregateInput
  _min: DocumentContentMinOrderByAggregateInput
  documentId: SortOrder
  file: SortOrder
  id: SortOrder
  text: SortOrder
}

input DocumentContentOrderByWithRelationInput {
  document: DocumentOrderByWithRelationInput
  documentId: SortOrder
  file: SortOrder
  id: SortOrder
  text: SortOrder
}

input DocumentContentRelationFilter {
  is: DocumentContentWhereInput
  isNot: DocumentContentWhereInput
}

enum DocumentContentScalarFieldEnum {
  documentId
  file
  id
  text
}

input DocumentContentScalarWhereWithAggregatesInput {
  AND: [DocumentContentScalarWhereWithAggregatesInput!]
  NOT: [DocumentContentScalarWhereWithAggregatesInput!]
  OR: [DocumentContentScalarWhereWithAggregatesInput!]
  documentId: StringWithAggregatesFilter
  file: BytesNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  text: StringNullableWithAggregatesFilter
}

input DocumentContentUpdateInput {
  document: DocumentUpdateOneRequiredWithoutDocumentContentInput
  file: NullableBytesFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  text: NullableStringFieldUpdateOperationsInput
}

input DocumentContentUpdateManyMutationInput {
  file: NullableBytesFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  text: NullableStringFieldUpdateOperationsInput
}

input DocumentContentUpdateOneWithoutDocumentInput {
  connect: DocumentContentWhereUniqueInput
  connectOrCreate: DocumentContentCreateOrConnectWithoutDocumentInput
  create: DocumentContentCreateWithoutDocumentInput
  delete: Boolean
  disconnect: Boolean
  update: DocumentContentUpdateWithoutDocumentInput
  upsert: DocumentContentUpsertWithoutDocumentInput
}

input DocumentContentUpdateWithoutDocumentInput {
  file: NullableBytesFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  text: NullableStringFieldUpdateOperationsInput
}

input DocumentContentUpsertWithoutDocumentInput {
  create: DocumentContentCreateWithoutDocumentInput!
  update: DocumentContentUpdateWithoutDocumentInput!
}

input DocumentContentWhereInput {
  AND: [DocumentContentWhereInput!]
  NOT: [DocumentContentWhereInput!]
  OR: [DocumentContentWhereInput!]
  document: DocumentRelationFilter
  documentId: StringFilter
  file: BytesNullableFilter
  id: StringFilter
  text: StringNullableFilter
}

input DocumentContentWhereUniqueInput {
  documentId: String
  id: String
}

type DocumentCount {
  personnel: Int!
  topics: Int!
}

type DocumentCountAggregate {
  _all: Int!
  beginDate: Int!
  driveId: Int!
  endDate: Int!
  fileName: Int!
  id: Int!
  orRequestDate: Int!
  orRequestor: Int!
  pages: Int!
  path: Int!
  relevanceScore: Int!
  sbrId: Int!
  summary: Int!
}

input DocumentCountOrderByAggregateInput {
  beginDate: SortOrder
  driveId: SortOrder
  endDate: SortOrder
  fileName: SortOrder
  id: SortOrder
  orRequestDate: SortOrder
  orRequestor: SortOrder
  pages: SortOrder
  path: SortOrder
  relevanceScore: SortOrder
  sbrId: SortOrder
  summary: SortOrder
}

input DocumentCreateInput {
  beginDate: DateTime
  documentContent: DocumentContentCreateNestedOneWithoutDocumentInput
  driveId: String!
  emailDetails: EmailDetailsCreateNestedOneWithoutDocumentInput
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  personnel: PersonnelCreateNestedManyWithoutDocumentsInput
  relevanceScore: Int
  sbrId: String!
  summary: String
  topics: TopicCreateNestedManyWithoutDocumentsInput
}

input DocumentCreateManyInput {
  beginDate: DateTime
  driveId: String!
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  relevanceScore: Int
  sbrId: String!
  summary: String
}

input DocumentCreateNestedManyWithoutPersonnelInput {
  connect: [DocumentWhereUniqueInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutPersonnelInput!]
  create: [DocumentCreateWithoutPersonnelInput!]
}

input DocumentCreateNestedManyWithoutTopicsInput {
  connect: [DocumentWhereUniqueInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutTopicsInput!]
  create: [DocumentCreateWithoutTopicsInput!]
}

input DocumentCreateNestedOneWithoutDocumentContentInput {
  connect: DocumentWhereUniqueInput
  connectOrCreate: DocumentCreateOrConnectWithoutDocumentContentInput
  create: DocumentCreateWithoutDocumentContentInput
}

input DocumentCreateNestedOneWithoutEmailDetailsInput {
  connect: DocumentWhereUniqueInput
  connectOrCreate: DocumentCreateOrConnectWithoutEmailDetailsInput
  create: DocumentCreateWithoutEmailDetailsInput
}

input DocumentCreateOrConnectWithoutDocumentContentInput {
  create: DocumentCreateWithoutDocumentContentInput!
  where: DocumentWhereUniqueInput!
}

input DocumentCreateOrConnectWithoutEmailDetailsInput {
  create: DocumentCreateWithoutEmailDetailsInput!
  where: DocumentWhereUniqueInput!
}

input DocumentCreateOrConnectWithoutPersonnelInput {
  create: DocumentCreateWithoutPersonnelInput!
  where: DocumentWhereUniqueInput!
}

input DocumentCreateOrConnectWithoutTopicsInput {
  create: DocumentCreateWithoutTopicsInput!
  where: DocumentWhereUniqueInput!
}

input DocumentCreateWithoutDocumentContentInput {
  beginDate: DateTime
  driveId: String!
  emailDetails: EmailDetailsCreateNestedOneWithoutDocumentInput
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  personnel: PersonnelCreateNestedManyWithoutDocumentsInput
  relevanceScore: Int
  sbrId: String!
  summary: String
  topics: TopicCreateNestedManyWithoutDocumentsInput
}

input DocumentCreateWithoutEmailDetailsInput {
  beginDate: DateTime
  documentContent: DocumentContentCreateNestedOneWithoutDocumentInput
  driveId: String!
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  personnel: PersonnelCreateNestedManyWithoutDocumentsInput
  relevanceScore: Int
  sbrId: String!
  summary: String
  topics: TopicCreateNestedManyWithoutDocumentsInput
}

input DocumentCreateWithoutPersonnelInput {
  beginDate: DateTime
  documentContent: DocumentContentCreateNestedOneWithoutDocumentInput
  driveId: String!
  emailDetails: EmailDetailsCreateNestedOneWithoutDocumentInput
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  relevanceScore: Int
  sbrId: String!
  summary: String
  topics: TopicCreateNestedManyWithoutDocumentsInput
}

input DocumentCreateWithoutTopicsInput {
  beginDate: DateTime
  documentContent: DocumentContentCreateNestedOneWithoutDocumentInput
  driveId: String!
  emailDetails: EmailDetailsCreateNestedOneWithoutDocumentInput
  endDate: DateTime
  fileName: String!
  id: String
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  personnel: PersonnelCreateNestedManyWithoutDocumentsInput
  relevanceScore: Int
  sbrId: String!
  summary: String
}

type DocumentGroupBy {
  _avg: DocumentAvgAggregate
  _count: DocumentCountAggregate
  _max: DocumentMaxAggregate
  _min: DocumentMinAggregate
  _sum: DocumentSumAggregate
  beginDate: DateTime
  driveId: String!
  endDate: DateTime
  fileName: String!
  id: String!
  orRequestDate: DateTime!
  orRequestor: String!
  pages: Int!
  path: String!
  relevanceScore: Int
  sbrId: String!
  summary: String
}

input DocumentListRelationFilter {
  every: DocumentWhereInput
  none: DocumentWhereInput
  some: DocumentWhereInput
}

type DocumentMaxAggregate {
  beginDate: DateTime
  driveId: String
  endDate: DateTime
  fileName: String
  id: String
  orRequestDate: DateTime
  orRequestor: String
  pages: Int
  path: String
  relevanceScore: Int
  sbrId: String
  summary: String
}

input DocumentMaxOrderByAggregateInput {
  beginDate: SortOrder
  driveId: SortOrder
  endDate: SortOrder
  fileName: SortOrder
  id: SortOrder
  orRequestDate: SortOrder
  orRequestor: SortOrder
  pages: SortOrder
  path: SortOrder
  relevanceScore: SortOrder
  sbrId: SortOrder
  summary: SortOrder
}

type DocumentMinAggregate {
  beginDate: DateTime
  driveId: String
  endDate: DateTime
  fileName: String
  id: String
  orRequestDate: DateTime
  orRequestor: String
  pages: Int
  path: String
  relevanceScore: Int
  sbrId: String
  summary: String
}

input DocumentMinOrderByAggregateInput {
  beginDate: SortOrder
  driveId: SortOrder
  endDate: SortOrder
  fileName: SortOrder
  id: SortOrder
  orRequestDate: SortOrder
  orRequestor: SortOrder
  pages: SortOrder
  path: SortOrder
  relevanceScore: SortOrder
  sbrId: SortOrder
  summary: SortOrder
}

input DocumentOrderByRelationAggregateInput {
  _count: SortOrder
}

input DocumentOrderByWithAggregationInput {
  _avg: DocumentAvgOrderByAggregateInput
  _count: DocumentCountOrderByAggregateInput
  _max: DocumentMaxOrderByAggregateInput
  _min: DocumentMinOrderByAggregateInput
  _sum: DocumentSumOrderByAggregateInput
  beginDate: SortOrder
  driveId: SortOrder
  endDate: SortOrder
  fileName: SortOrder
  id: SortOrder
  orRequestDate: SortOrder
  orRequestor: SortOrder
  pages: SortOrder
  path: SortOrder
  relevanceScore: SortOrder
  sbrId: SortOrder
  summary: SortOrder
}

input DocumentOrderByWithRelationInput {
  beginDate: SortOrder
  documentContent: DocumentContentOrderByWithRelationInput
  driveId: SortOrder
  emailDetails: EmailDetailsOrderByWithRelationInput
  endDate: SortOrder
  fileName: SortOrder
  id: SortOrder
  orRequestDate: SortOrder
  orRequestor: SortOrder
  pages: SortOrder
  path: SortOrder
  personnel: PersonnelOrderByRelationAggregateInput
  relevanceScore: SortOrder
  sbrId: SortOrder
  summary: SortOrder
  topics: TopicOrderByRelationAggregateInput
}

input DocumentRelationFilter {
  is: DocumentWhereInput
  isNot: DocumentWhereInput
}

enum DocumentScalarFieldEnum {
  beginDate
  driveId
  endDate
  fileName
  id
  orRequestDate
  orRequestor
  pages
  path
  relevanceScore
  sbrId
  summary
}

input DocumentScalarWhereInput {
  AND: [DocumentScalarWhereInput!]
  NOT: [DocumentScalarWhereInput!]
  OR: [DocumentScalarWhereInput!]
  beginDate: DateTimeNullableFilter
  driveId: StringFilter
  endDate: DateTimeNullableFilter
  fileName: StringFilter
  id: StringFilter
  orRequestDate: DateTimeFilter
  orRequestor: StringFilter
  pages: IntFilter
  path: StringFilter
  relevanceScore: IntNullableFilter
  sbrId: StringFilter
  summary: StringNullableFilter
}

input DocumentScalarWhereWithAggregatesInput {
  AND: [DocumentScalarWhereWithAggregatesInput!]
  NOT: [DocumentScalarWhereWithAggregatesInput!]
  OR: [DocumentScalarWhereWithAggregatesInput!]
  beginDate: DateTimeNullableWithAggregatesFilter
  driveId: StringWithAggregatesFilter
  endDate: DateTimeNullableWithAggregatesFilter
  fileName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  orRequestDate: DateTimeWithAggregatesFilter
  orRequestor: StringWithAggregatesFilter
  pages: IntWithAggregatesFilter
  path: StringWithAggregatesFilter
  relevanceScore: IntNullableWithAggregatesFilter
  sbrId: StringWithAggregatesFilter
  summary: StringNullableWithAggregatesFilter
}

type DocumentSumAggregate {
  pages: Int
  relevanceScore: Int
}

input DocumentSumOrderByAggregateInput {
  pages: SortOrder
  relevanceScore: SortOrder
}

input DocumentUpdateInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  documentContent: DocumentContentUpdateOneWithoutDocumentInput
  driveId: StringFieldUpdateOperationsInput
  emailDetails: EmailDetailsUpdateOneWithoutDocumentInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  personnel: PersonnelUpdateManyWithoutDocumentsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
  topics: TopicUpdateManyWithoutDocumentsInput
}

input DocumentUpdateManyMutationInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  driveId: StringFieldUpdateOperationsInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
}

input DocumentUpdateManyWithWhereWithoutPersonnelInput {
  data: DocumentUpdateManyMutationInput!
  where: DocumentScalarWhereInput!
}

input DocumentUpdateManyWithWhereWithoutTopicsInput {
  data: DocumentUpdateManyMutationInput!
  where: DocumentScalarWhereInput!
}

input DocumentUpdateManyWithoutPersonnelInput {
  connect: [DocumentWhereUniqueInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutPersonnelInput!]
  create: [DocumentCreateWithoutPersonnelInput!]
  delete: [DocumentWhereUniqueInput!]
  deleteMany: [DocumentScalarWhereInput!]
  disconnect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
  update: [DocumentUpdateWithWhereUniqueWithoutPersonnelInput!]
  updateMany: [DocumentUpdateManyWithWhereWithoutPersonnelInput!]
  upsert: [DocumentUpsertWithWhereUniqueWithoutPersonnelInput!]
}

input DocumentUpdateManyWithoutTopicsInput {
  connect: [DocumentWhereUniqueInput!]
  connectOrCreate: [DocumentCreateOrConnectWithoutTopicsInput!]
  create: [DocumentCreateWithoutTopicsInput!]
  delete: [DocumentWhereUniqueInput!]
  deleteMany: [DocumentScalarWhereInput!]
  disconnect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
  update: [DocumentUpdateWithWhereUniqueWithoutTopicsInput!]
  updateMany: [DocumentUpdateManyWithWhereWithoutTopicsInput!]
  upsert: [DocumentUpsertWithWhereUniqueWithoutTopicsInput!]
}

input DocumentUpdateOneRequiredWithoutDocumentContentInput {
  connect: DocumentWhereUniqueInput
  connectOrCreate: DocumentCreateOrConnectWithoutDocumentContentInput
  create: DocumentCreateWithoutDocumentContentInput
  update: DocumentUpdateWithoutDocumentContentInput
  upsert: DocumentUpsertWithoutDocumentContentInput
}

input DocumentUpdateOneRequiredWithoutEmailDetailsInput {
  connect: DocumentWhereUniqueInput
  connectOrCreate: DocumentCreateOrConnectWithoutEmailDetailsInput
  create: DocumentCreateWithoutEmailDetailsInput
  update: DocumentUpdateWithoutEmailDetailsInput
  upsert: DocumentUpsertWithoutEmailDetailsInput
}

input DocumentUpdateWithWhereUniqueWithoutPersonnelInput {
  data: DocumentUpdateWithoutPersonnelInput!
  where: DocumentWhereUniqueInput!
}

input DocumentUpdateWithWhereUniqueWithoutTopicsInput {
  data: DocumentUpdateWithoutTopicsInput!
  where: DocumentWhereUniqueInput!
}

input DocumentUpdateWithoutDocumentContentInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  driveId: StringFieldUpdateOperationsInput
  emailDetails: EmailDetailsUpdateOneWithoutDocumentInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  personnel: PersonnelUpdateManyWithoutDocumentsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
  topics: TopicUpdateManyWithoutDocumentsInput
}

input DocumentUpdateWithoutEmailDetailsInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  documentContent: DocumentContentUpdateOneWithoutDocumentInput
  driveId: StringFieldUpdateOperationsInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  personnel: PersonnelUpdateManyWithoutDocumentsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
  topics: TopicUpdateManyWithoutDocumentsInput
}

input DocumentUpdateWithoutPersonnelInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  documentContent: DocumentContentUpdateOneWithoutDocumentInput
  driveId: StringFieldUpdateOperationsInput
  emailDetails: EmailDetailsUpdateOneWithoutDocumentInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
  topics: TopicUpdateManyWithoutDocumentsInput
}

input DocumentUpdateWithoutTopicsInput {
  beginDate: NullableDateTimeFieldUpdateOperationsInput
  documentContent: DocumentContentUpdateOneWithoutDocumentInput
  driveId: StringFieldUpdateOperationsInput
  emailDetails: EmailDetailsUpdateOneWithoutDocumentInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  fileName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  orRequestDate: DateTimeFieldUpdateOperationsInput
  orRequestor: StringFieldUpdateOperationsInput
  pages: IntFieldUpdateOperationsInput
  path: StringFieldUpdateOperationsInput
  personnel: PersonnelUpdateManyWithoutDocumentsInput
  relevanceScore: NullableIntFieldUpdateOperationsInput
  sbrId: StringFieldUpdateOperationsInput
  summary: NullableStringFieldUpdateOperationsInput
}

input DocumentUpsertWithWhereUniqueWithoutPersonnelInput {
  create: DocumentCreateWithoutPersonnelInput!
  update: DocumentUpdateWithoutPersonnelInput!
  where: DocumentWhereUniqueInput!
}

input DocumentUpsertWithWhereUniqueWithoutTopicsInput {
  create: DocumentCreateWithoutTopicsInput!
  update: DocumentUpdateWithoutTopicsInput!
  where: DocumentWhereUniqueInput!
}

input DocumentUpsertWithoutDocumentContentInput {
  create: DocumentCreateWithoutDocumentContentInput!
  update: DocumentUpdateWithoutDocumentContentInput!
}

input DocumentUpsertWithoutEmailDetailsInput {
  create: DocumentCreateWithoutEmailDetailsInput!
  update: DocumentUpdateWithoutEmailDetailsInput!
}

input DocumentWhereInput {
  AND: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  beginDate: DateTimeNullableFilter
  documentContent: DocumentContentRelationFilter
  driveId: StringFilter
  emailDetails: EmailDetailsRelationFilter
  endDate: DateTimeNullableFilter
  fileName: StringFilter
  id: StringFilter
  orRequestDate: DateTimeFilter
  orRequestor: StringFilter
  pages: IntFilter
  path: StringFilter
  personnel: PersonnelListRelationFilter
  relevanceScore: IntNullableFilter
  sbrId: StringFilter
  summary: StringNullableFilter
  topics: TopicListRelationFilter
}

input DocumentWhereUniqueInput {
  id: String
  sbrId: String
}

type EmailDetails {
  bcc: String
  cc: String
  document: Document!
  documentId: String!
  from: String!
  id: String!
  subject: String!
  to: String!
}

type EmailDetailsCountAggregate {
  _all: Int!
  bcc: Int!
  cc: Int!
  documentId: Int!
  from: Int!
  id: Int!
  subject: Int!
  to: Int!
}

input EmailDetailsCountOrderByAggregateInput {
  bcc: SortOrder
  cc: SortOrder
  documentId: SortOrder
  from: SortOrder
  id: SortOrder
  subject: SortOrder
  to: SortOrder
}

input EmailDetailsCreateInput {
  bcc: String
  cc: String
  document: DocumentCreateNestedOneWithoutEmailDetailsInput!
  from: String!
  id: String
  subject: String!
  to: String!
}

input EmailDetailsCreateManyInput {
  bcc: String
  cc: String
  documentId: String!
  from: String!
  id: String
  subject: String!
  to: String!
}

input EmailDetailsCreateNestedOneWithoutDocumentInput {
  connect: EmailDetailsWhereUniqueInput
  connectOrCreate: EmailDetailsCreateOrConnectWithoutDocumentInput
  create: EmailDetailsCreateWithoutDocumentInput
}

input EmailDetailsCreateOrConnectWithoutDocumentInput {
  create: EmailDetailsCreateWithoutDocumentInput!
  where: EmailDetailsWhereUniqueInput!
}

input EmailDetailsCreateWithoutDocumentInput {
  bcc: String
  cc: String
  from: String!
  id: String
  subject: String!
  to: String!
}

type EmailDetailsGroupBy {
  _count: EmailDetailsCountAggregate
  _max: EmailDetailsMaxAggregate
  _min: EmailDetailsMinAggregate
  bcc: String
  cc: String
  documentId: String!
  from: String!
  id: String!
  subject: String!
  to: String!
}

type EmailDetailsMaxAggregate {
  bcc: String
  cc: String
  documentId: String
  from: String
  id: String
  subject: String
  to: String
}

input EmailDetailsMaxOrderByAggregateInput {
  bcc: SortOrder
  cc: SortOrder
  documentId: SortOrder
  from: SortOrder
  id: SortOrder
  subject: SortOrder
  to: SortOrder
}

type EmailDetailsMinAggregate {
  bcc: String
  cc: String
  documentId: String
  from: String
  id: String
  subject: String
  to: String
}

input EmailDetailsMinOrderByAggregateInput {
  bcc: SortOrder
  cc: SortOrder
  documentId: SortOrder
  from: SortOrder
  id: SortOrder
  subject: SortOrder
  to: SortOrder
}

input EmailDetailsOrderByWithAggregationInput {
  _count: EmailDetailsCountOrderByAggregateInput
  _max: EmailDetailsMaxOrderByAggregateInput
  _min: EmailDetailsMinOrderByAggregateInput
  bcc: SortOrder
  cc: SortOrder
  documentId: SortOrder
  from: SortOrder
  id: SortOrder
  subject: SortOrder
  to: SortOrder
}

input EmailDetailsOrderByWithRelationInput {
  bcc: SortOrder
  cc: SortOrder
  document: DocumentOrderByWithRelationInput
  documentId: SortOrder
  from: SortOrder
  id: SortOrder
  subject: SortOrder
  to: SortOrder
}

input EmailDetailsRelationFilter {
  is: EmailDetailsWhereInput
  isNot: EmailDetailsWhereInput
}

enum EmailDetailsScalarFieldEnum {
  bcc
  cc
  documentId
  from
  id
  subject
  to
}

input EmailDetailsScalarWhereWithAggregatesInput {
  AND: [EmailDetailsScalarWhereWithAggregatesInput!]
  NOT: [EmailDetailsScalarWhereWithAggregatesInput!]
  OR: [EmailDetailsScalarWhereWithAggregatesInput!]
  bcc: StringNullableWithAggregatesFilter
  cc: StringNullableWithAggregatesFilter
  documentId: StringWithAggregatesFilter
  from: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  subject: StringWithAggregatesFilter
  to: StringWithAggregatesFilter
}

input EmailDetailsUpdateInput {
  bcc: NullableStringFieldUpdateOperationsInput
  cc: NullableStringFieldUpdateOperationsInput
  document: DocumentUpdateOneRequiredWithoutEmailDetailsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
  to: StringFieldUpdateOperationsInput
}

input EmailDetailsUpdateManyMutationInput {
  bcc: NullableStringFieldUpdateOperationsInput
  cc: NullableStringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
  to: StringFieldUpdateOperationsInput
}

input EmailDetailsUpdateOneWithoutDocumentInput {
  connect: EmailDetailsWhereUniqueInput
  connectOrCreate: EmailDetailsCreateOrConnectWithoutDocumentInput
  create: EmailDetailsCreateWithoutDocumentInput
  delete: Boolean
  disconnect: Boolean
  update: EmailDetailsUpdateWithoutDocumentInput
  upsert: EmailDetailsUpsertWithoutDocumentInput
}

input EmailDetailsUpdateWithoutDocumentInput {
  bcc: NullableStringFieldUpdateOperationsInput
  cc: NullableStringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
  to: StringFieldUpdateOperationsInput
}

input EmailDetailsUpsertWithoutDocumentInput {
  create: EmailDetailsCreateWithoutDocumentInput!
  update: EmailDetailsUpdateWithoutDocumentInput!
}

input EmailDetailsWhereInput {
  AND: [EmailDetailsWhereInput!]
  NOT: [EmailDetailsWhereInput!]
  OR: [EmailDetailsWhereInput!]
  bcc: StringNullableFilter
  cc: StringNullableFilter
  document: DocumentRelationFilter
  documentId: StringFilter
  from: StringFilter
  id: StringFilter
  subject: StringFilter
  to: StringFilter
}

input EmailDetailsWhereUniqueInput {
  documentId: String
  id: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createDocument(data: DocumentCreateInput!): Document!
  createDocumentContent(data: DocumentContentCreateInput!): DocumentContent!
  createEmailDetails(data: EmailDetailsCreateInput!): EmailDetails!
  createManyDocument(data: [DocumentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDocumentContent(data: [DocumentContentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEmailDetails(data: [EmailDetailsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOrganization(data: [OrganizationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPersonnel(data: [PersonnelCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTopic(data: [TopicCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOrganization(data: OrganizationCreateInput!): Organization!
  createPersonnel(data: PersonnelCreateInput!): Personnel!
  createTopic(data: TopicCreateInput!): Topic!
  createUser(data: UserCreateInput!): User!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteDocumentContent(where: DocumentContentWhereUniqueInput!): DocumentContent
  deleteEmailDetails(where: EmailDetailsWhereUniqueInput!): EmailDetails
  deleteManyDocument(where: DocumentWhereInput): AffectedRowsOutput!
  deleteManyDocumentContent(where: DocumentContentWhereInput): AffectedRowsOutput!
  deleteManyEmailDetails(where: EmailDetailsWhereInput): AffectedRowsOutput!
  deleteManyOrganization(where: OrganizationWhereInput): AffectedRowsOutput!
  deleteManyPersonnel(where: PersonnelWhereInput): AffectedRowsOutput!
  deleteManyTopic(where: TopicWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deletePersonnel(where: PersonnelWhereUniqueInput!): Personnel
  deleteTopic(where: TopicWhereUniqueInput!): Topic
  deleteUser(where: UserWhereUniqueInput!): User
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateDocumentContent(data: DocumentContentUpdateInput!, where: DocumentContentWhereUniqueInput!): DocumentContent
  updateEmailDetails(data: EmailDetailsUpdateInput!, where: EmailDetailsWhereUniqueInput!): EmailDetails
  updateManyDocument(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): AffectedRowsOutput!
  updateManyDocumentContent(data: DocumentContentUpdateManyMutationInput!, where: DocumentContentWhereInput): AffectedRowsOutput!
  updateManyEmailDetails(data: EmailDetailsUpdateManyMutationInput!, where: EmailDetailsWhereInput): AffectedRowsOutput!
  updateManyOrganization(data: OrganizationUpdateManyMutationInput!, where: OrganizationWhereInput): AffectedRowsOutput!
  updateManyPersonnel(data: PersonnelUpdateManyMutationInput!, where: PersonnelWhereInput): AffectedRowsOutput!
  updateManyTopic(data: TopicUpdateManyMutationInput!, where: TopicWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOrganization(data: OrganizationUpdateInput!, where: OrganizationWhereUniqueInput!): Organization
  updatePersonnel(data: PersonnelUpdateInput!, where: PersonnelWhereUniqueInput!): Personnel
  updateTopic(data: TopicUpdateInput!, where: TopicWhereUniqueInput!): Topic
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertDocument(create: DocumentCreateInput!, update: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document!
  upsertDocumentContent(create: DocumentContentCreateInput!, update: DocumentContentUpdateInput!, where: DocumentContentWhereUniqueInput!): DocumentContent!
  upsertEmailDetails(create: EmailDetailsCreateInput!, update: EmailDetailsUpdateInput!, where: EmailDetailsWhereUniqueInput!): EmailDetails!
  upsertOrganization(create: OrganizationCreateInput!, update: OrganizationUpdateInput!, where: OrganizationWhereUniqueInput!): Organization!
  upsertPersonnel(create: PersonnelCreateInput!, update: PersonnelUpdateInput!, where: PersonnelWhereUniqueInput!): Personnel!
  upsertTopic(create: TopicCreateInput!, update: TopicUpdateInput!, where: TopicWhereUniqueInput!): Topic!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBytesNullableFilter {
  equals: Byte
  not: NestedBytesNullableFilter
}

input NestedBytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  not: NestedBytesNullableWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableBytesFieldUpdateOperationsInput {
  set: Byte
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Organization {
  _count: OrganizationCount
  id: String!
  name: String!
  personnel(cursor: PersonnelWhereUniqueInput, distinct: [PersonnelScalarFieldEnum!], orderBy: [PersonnelOrderByWithRelationInput!], skip: Int, take: Int, where: PersonnelWhereInput): [Personnel!]!
}

type OrganizationCount {
  personnel: Int!
}

type OrganizationCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input OrganizationCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input OrganizationCreateInput {
  id: String
  name: String!
  personnel: PersonnelCreateNestedManyWithoutOrganizationInput
}

input OrganizationCreateManyInput {
  id: String
  name: String!
}

input OrganizationCreateNestedOneWithoutPersonnelInput {
  connect: OrganizationWhereUniqueInput
  connectOrCreate: OrganizationCreateOrConnectWithoutPersonnelInput
  create: OrganizationCreateWithoutPersonnelInput
}

input OrganizationCreateOrConnectWithoutPersonnelInput {
  create: OrganizationCreateWithoutPersonnelInput!
  where: OrganizationWhereUniqueInput!
}

input OrganizationCreateWithoutPersonnelInput {
  id: String
  name: String!
}

type OrganizationGroupBy {
  _count: OrganizationCountAggregate
  _max: OrganizationMaxAggregate
  _min: OrganizationMinAggregate
  id: String!
  name: String!
}

type OrganizationMaxAggregate {
  id: String
  name: String
}

input OrganizationMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type OrganizationMinAggregate {
  id: String
  name: String
}

input OrganizationMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input OrganizationOrderByWithAggregationInput {
  _count: OrganizationCountOrderByAggregateInput
  _max: OrganizationMaxOrderByAggregateInput
  _min: OrganizationMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input OrganizationOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  personnel: PersonnelOrderByRelationAggregateInput
}

input OrganizationRelationFilter {
  is: OrganizationWhereInput
  isNot: OrganizationWhereInput
}

enum OrganizationScalarFieldEnum {
  id
  name
}

input OrganizationScalarWhereWithAggregatesInput {
  AND: [OrganizationScalarWhereWithAggregatesInput!]
  NOT: [OrganizationScalarWhereWithAggregatesInput!]
  OR: [OrganizationScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input OrganizationUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  personnel: PersonnelUpdateManyWithoutOrganizationInput
}

input OrganizationUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input OrganizationUpdateOneWithoutPersonnelInput {
  connect: OrganizationWhereUniqueInput
  connectOrCreate: OrganizationCreateOrConnectWithoutPersonnelInput
  create: OrganizationCreateWithoutPersonnelInput
  delete: Boolean
  disconnect: Boolean
  update: OrganizationUpdateWithoutPersonnelInput
  upsert: OrganizationUpsertWithoutPersonnelInput
}

input OrganizationUpdateWithoutPersonnelInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input OrganizationUpsertWithoutPersonnelInput {
  create: OrganizationCreateWithoutPersonnelInput!
  update: OrganizationUpdateWithoutPersonnelInput!
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  id: StringFilter
  name: StringFilter
  personnel: PersonnelListRelationFilter
}

input OrganizationWhereUniqueInput {
  id: String
}

type Personnel {
  _count: PersonnelCount
  documents(cursor: DocumentWhereUniqueInput, distinct: [DocumentScalarFieldEnum!], orderBy: [DocumentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentWhereInput): [Document!]!
  email: String
  firstName: String
  id: String!
  lastName: String
  organization: Organization
  organizationId: String
}

type PersonnelCount {
  documents: Int!
}

type PersonnelCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  organizationId: Int!
}

input PersonnelCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  organizationId: SortOrder
}

input PersonnelCreateInput {
  documents: DocumentCreateNestedManyWithoutPersonnelInput
  email: String
  firstName: String
  id: String
  lastName: String
  organization: OrganizationCreateNestedOneWithoutPersonnelInput
}

input PersonnelCreateManyInput {
  email: String
  firstName: String
  id: String
  lastName: String
  organizationId: String
}

input PersonnelCreateManyOrganizationInput {
  email: String
  firstName: String
  id: String
  lastName: String
}

input PersonnelCreateManyOrganizationInputEnvelope {
  data: [PersonnelCreateManyOrganizationInput!]!
  skipDuplicates: Boolean
}

input PersonnelCreateNestedManyWithoutDocumentsInput {
  connect: [PersonnelWhereUniqueInput!]
  connectOrCreate: [PersonnelCreateOrConnectWithoutDocumentsInput!]
  create: [PersonnelCreateWithoutDocumentsInput!]
}

input PersonnelCreateNestedManyWithoutOrganizationInput {
  connect: [PersonnelWhereUniqueInput!]
  connectOrCreate: [PersonnelCreateOrConnectWithoutOrganizationInput!]
  create: [PersonnelCreateWithoutOrganizationInput!]
  createMany: PersonnelCreateManyOrganizationInputEnvelope
}

input PersonnelCreateOrConnectWithoutDocumentsInput {
  create: PersonnelCreateWithoutDocumentsInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelCreateOrConnectWithoutOrganizationInput {
  create: PersonnelCreateWithoutOrganizationInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelCreateWithoutDocumentsInput {
  email: String
  firstName: String
  id: String
  lastName: String
  organization: OrganizationCreateNestedOneWithoutPersonnelInput
}

input PersonnelCreateWithoutOrganizationInput {
  documents: DocumentCreateNestedManyWithoutPersonnelInput
  email: String
  firstName: String
  id: String
  lastName: String
}

type PersonnelGroupBy {
  _count: PersonnelCountAggregate
  _max: PersonnelMaxAggregate
  _min: PersonnelMinAggregate
  email: String
  firstName: String
  id: String!
  lastName: String
  organizationId: String
}

input PersonnelListRelationFilter {
  every: PersonnelWhereInput
  none: PersonnelWhereInput
  some: PersonnelWhereInput
}

type PersonnelMaxAggregate {
  email: String
  firstName: String
  id: String
  lastName: String
  organizationId: String
}

input PersonnelMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  organizationId: SortOrder
}

type PersonnelMinAggregate {
  email: String
  firstName: String
  id: String
  lastName: String
  organizationId: String
}

input PersonnelMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  organizationId: SortOrder
}

input PersonnelOrderByRelationAggregateInput {
  _count: SortOrder
}

input PersonnelOrderByWithAggregationInput {
  _count: PersonnelCountOrderByAggregateInput
  _max: PersonnelMaxOrderByAggregateInput
  _min: PersonnelMinOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  organizationId: SortOrder
}

input PersonnelOrderByWithRelationInput {
  documents: DocumentOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  organization: OrganizationOrderByWithRelationInput
  organizationId: SortOrder
}

enum PersonnelScalarFieldEnum {
  email
  firstName
  id
  lastName
  organizationId
}

input PersonnelScalarWhereInput {
  AND: [PersonnelScalarWhereInput!]
  NOT: [PersonnelScalarWhereInput!]
  OR: [PersonnelScalarWhereInput!]
  email: StringNullableFilter
  firstName: StringNullableFilter
  id: StringFilter
  lastName: StringNullableFilter
  organizationId: StringNullableFilter
}

input PersonnelScalarWhereWithAggregatesInput {
  AND: [PersonnelScalarWhereWithAggregatesInput!]
  NOT: [PersonnelScalarWhereWithAggregatesInput!]
  OR: [PersonnelScalarWhereWithAggregatesInput!]
  email: StringNullableWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  organizationId: StringNullableWithAggregatesFilter
}

input PersonnelUpdateInput {
  documents: DocumentUpdateManyWithoutPersonnelInput
  email: NullableStringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  organization: OrganizationUpdateOneWithoutPersonnelInput
}

input PersonnelUpdateManyMutationInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
}

input PersonnelUpdateManyWithWhereWithoutDocumentsInput {
  data: PersonnelUpdateManyMutationInput!
  where: PersonnelScalarWhereInput!
}

input PersonnelUpdateManyWithWhereWithoutOrganizationInput {
  data: PersonnelUpdateManyMutationInput!
  where: PersonnelScalarWhereInput!
}

input PersonnelUpdateManyWithoutDocumentsInput {
  connect: [PersonnelWhereUniqueInput!]
  connectOrCreate: [PersonnelCreateOrConnectWithoutDocumentsInput!]
  create: [PersonnelCreateWithoutDocumentsInput!]
  delete: [PersonnelWhereUniqueInput!]
  deleteMany: [PersonnelScalarWhereInput!]
  disconnect: [PersonnelWhereUniqueInput!]
  set: [PersonnelWhereUniqueInput!]
  update: [PersonnelUpdateWithWhereUniqueWithoutDocumentsInput!]
  updateMany: [PersonnelUpdateManyWithWhereWithoutDocumentsInput!]
  upsert: [PersonnelUpsertWithWhereUniqueWithoutDocumentsInput!]
}

input PersonnelUpdateManyWithoutOrganizationInput {
  connect: [PersonnelWhereUniqueInput!]
  connectOrCreate: [PersonnelCreateOrConnectWithoutOrganizationInput!]
  create: [PersonnelCreateWithoutOrganizationInput!]
  createMany: PersonnelCreateManyOrganizationInputEnvelope
  delete: [PersonnelWhereUniqueInput!]
  deleteMany: [PersonnelScalarWhereInput!]
  disconnect: [PersonnelWhereUniqueInput!]
  set: [PersonnelWhereUniqueInput!]
  update: [PersonnelUpdateWithWhereUniqueWithoutOrganizationInput!]
  updateMany: [PersonnelUpdateManyWithWhereWithoutOrganizationInput!]
  upsert: [PersonnelUpsertWithWhereUniqueWithoutOrganizationInput!]
}

input PersonnelUpdateWithWhereUniqueWithoutDocumentsInput {
  data: PersonnelUpdateWithoutDocumentsInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelUpdateWithWhereUniqueWithoutOrganizationInput {
  data: PersonnelUpdateWithoutOrganizationInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelUpdateWithoutDocumentsInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  organization: OrganizationUpdateOneWithoutPersonnelInput
}

input PersonnelUpdateWithoutOrganizationInput {
  documents: DocumentUpdateManyWithoutPersonnelInput
  email: NullableStringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
}

input PersonnelUpsertWithWhereUniqueWithoutDocumentsInput {
  create: PersonnelCreateWithoutDocumentsInput!
  update: PersonnelUpdateWithoutDocumentsInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelUpsertWithWhereUniqueWithoutOrganizationInput {
  create: PersonnelCreateWithoutOrganizationInput!
  update: PersonnelUpdateWithoutOrganizationInput!
  where: PersonnelWhereUniqueInput!
}

input PersonnelWhereInput {
  AND: [PersonnelWhereInput!]
  NOT: [PersonnelWhereInput!]
  OR: [PersonnelWhereInput!]
  documents: DocumentListRelationFilter
  email: StringNullableFilter
  firstName: StringNullableFilter
  id: StringFilter
  lastName: StringNullableFilter
  organization: OrganizationRelationFilter
  organizationId: StringNullableFilter
}

input PersonnelWhereUniqueInput {
  id: String
}

type Query {
  aggregateDocument(cursor: DocumentWhereUniqueInput, orderBy: [DocumentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentWhereInput): AggregateDocument!
  aggregateDocumentContent(cursor: DocumentContentWhereUniqueInput, orderBy: [DocumentContentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentContentWhereInput): AggregateDocumentContent!
  aggregateEmailDetails(cursor: EmailDetailsWhereUniqueInput, orderBy: [EmailDetailsOrderByWithRelationInput!], skip: Int, take: Int, where: EmailDetailsWhereInput): AggregateEmailDetails!
  aggregateOrganization(cursor: OrganizationWhereUniqueInput, orderBy: [OrganizationOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizationWhereInput): AggregateOrganization!
  aggregatePersonnel(cursor: PersonnelWhereUniqueInput, orderBy: [PersonnelOrderByWithRelationInput!], skip: Int, take: Int, where: PersonnelWhereInput): AggregatePersonnel!
  aggregateTopic(cursor: TopicWhereUniqueInput, orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): AggregateTopic!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  document(where: DocumentWhereUniqueInput!): Document
  documentContent(where: DocumentContentWhereUniqueInput!): DocumentContent
  documentContents(cursor: DocumentContentWhereUniqueInput, distinct: [DocumentContentScalarFieldEnum!], orderBy: [DocumentContentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentContentWhereInput): [DocumentContent!]!
  documents(cursor: DocumentWhereUniqueInput, distinct: [DocumentScalarFieldEnum!], orderBy: [DocumentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentWhereInput): [Document!]!
  findFirstDocument(cursor: DocumentWhereUniqueInput, distinct: [DocumentScalarFieldEnum!], orderBy: [DocumentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentWhereInput): Document
  findFirstDocumentContent(cursor: DocumentContentWhereUniqueInput, distinct: [DocumentContentScalarFieldEnum!], orderBy: [DocumentContentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentContentWhereInput): DocumentContent
  findFirstEmailDetails(cursor: EmailDetailsWhereUniqueInput, distinct: [EmailDetailsScalarFieldEnum!], orderBy: [EmailDetailsOrderByWithRelationInput!], skip: Int, take: Int, where: EmailDetailsWhereInput): EmailDetails
  findFirstOrganization(cursor: OrganizationWhereUniqueInput, distinct: [OrganizationScalarFieldEnum!], orderBy: [OrganizationOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizationWhereInput): Organization
  findFirstPersonnel(cursor: PersonnelWhereUniqueInput, distinct: [PersonnelScalarFieldEnum!], orderBy: [PersonnelOrderByWithRelationInput!], skip: Int, take: Int, where: PersonnelWhereInput): Personnel
  findFirstTopic(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): Topic
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyEmailDetails(cursor: EmailDetailsWhereUniqueInput, distinct: [EmailDetailsScalarFieldEnum!], orderBy: [EmailDetailsOrderByWithRelationInput!], skip: Int, take: Int, where: EmailDetailsWhereInput): [EmailDetails!]!
  findManyPersonnel(cursor: PersonnelWhereUniqueInput, distinct: [PersonnelScalarFieldEnum!], orderBy: [PersonnelOrderByWithRelationInput!], skip: Int, take: Int, where: PersonnelWhereInput): [Personnel!]!
  findUniqueEmailDetails(where: EmailDetailsWhereUniqueInput!): EmailDetails
  findUniquePersonnel(where: PersonnelWhereUniqueInput!): Personnel
  groupByDocument(by: [DocumentScalarFieldEnum!]!, having: DocumentScalarWhereWithAggregatesInput, orderBy: [DocumentOrderByWithAggregationInput!], skip: Int, take: Int, where: DocumentWhereInput): [DocumentGroupBy!]!
  groupByDocumentContent(by: [DocumentContentScalarFieldEnum!]!, having: DocumentContentScalarWhereWithAggregatesInput, orderBy: [DocumentContentOrderByWithAggregationInput!], skip: Int, take: Int, where: DocumentContentWhereInput): [DocumentContentGroupBy!]!
  groupByEmailDetails(by: [EmailDetailsScalarFieldEnum!]!, having: EmailDetailsScalarWhereWithAggregatesInput, orderBy: [EmailDetailsOrderByWithAggregationInput!], skip: Int, take: Int, where: EmailDetailsWhereInput): [EmailDetailsGroupBy!]!
  groupByOrganization(by: [OrganizationScalarFieldEnum!]!, having: OrganizationScalarWhereWithAggregatesInput, orderBy: [OrganizationOrderByWithAggregationInput!], skip: Int, take: Int, where: OrganizationWhereInput): [OrganizationGroupBy!]!
  groupByPersonnel(by: [PersonnelScalarFieldEnum!]!, having: PersonnelScalarWhereWithAggregatesInput, orderBy: [PersonnelOrderByWithAggregationInput!], skip: Int, take: Int, where: PersonnelWhereInput): [PersonnelGroupBy!]!
  groupByTopic(by: [TopicScalarFieldEnum!]!, having: TopicScalarWhereWithAggregatesInput, orderBy: [TopicOrderByWithAggregationInput!], skip: Int, take: Int, where: TopicWhereInput): [TopicGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(cursor: OrganizationWhereUniqueInput, distinct: [OrganizationScalarFieldEnum!], orderBy: [OrganizationOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizationWhereInput): [Organization!]!
  topic(where: TopicWhereUniqueInput!): Topic
  topics(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): [Topic!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Topic {
  _count: TopicCount
  documents(cursor: DocumentWhereUniqueInput, distinct: [DocumentScalarFieldEnum!], orderBy: [DocumentOrderByWithRelationInput!], skip: Int, take: Int, where: DocumentWhereInput): [Document!]!
  id: String!
  name: String!
}

type TopicCount {
  documents: Int!
}

type TopicCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input TopicCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TopicCreateInput {
  documents: DocumentCreateNestedManyWithoutTopicsInput
  id: String
  name: String!
}

input TopicCreateManyInput {
  id: String
  name: String!
}

input TopicCreateNestedManyWithoutDocumentsInput {
  connect: [TopicWhereUniqueInput!]
  connectOrCreate: [TopicCreateOrConnectWithoutDocumentsInput!]
  create: [TopicCreateWithoutDocumentsInput!]
}

input TopicCreateOrConnectWithoutDocumentsInput {
  create: TopicCreateWithoutDocumentsInput!
  where: TopicWhereUniqueInput!
}

input TopicCreateWithoutDocumentsInput {
  id: String
  name: String!
}

type TopicGroupBy {
  _count: TopicCountAggregate
  _max: TopicMaxAggregate
  _min: TopicMinAggregate
  id: String!
  name: String!
}

input TopicListRelationFilter {
  every: TopicWhereInput
  none: TopicWhereInput
  some: TopicWhereInput
}

type TopicMaxAggregate {
  id: String
  name: String
}

input TopicMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type TopicMinAggregate {
  id: String
  name: String
}

input TopicMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input TopicOrderByRelationAggregateInput {
  _count: SortOrder
}

input TopicOrderByWithAggregationInput {
  _count: TopicCountOrderByAggregateInput
  _max: TopicMaxOrderByAggregateInput
  _min: TopicMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input TopicOrderByWithRelationInput {
  documents: DocumentOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

enum TopicScalarFieldEnum {
  id
  name
}

input TopicScalarWhereInput {
  AND: [TopicScalarWhereInput!]
  NOT: [TopicScalarWhereInput!]
  OR: [TopicScalarWhereInput!]
  id: StringFilter
  name: StringFilter
}

input TopicScalarWhereWithAggregatesInput {
  AND: [TopicScalarWhereWithAggregatesInput!]
  NOT: [TopicScalarWhereWithAggregatesInput!]
  OR: [TopicScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input TopicUpdateInput {
  documents: DocumentUpdateManyWithoutTopicsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TopicUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TopicUpdateManyWithWhereWithoutDocumentsInput {
  data: TopicUpdateManyMutationInput!
  where: TopicScalarWhereInput!
}

input TopicUpdateManyWithoutDocumentsInput {
  connect: [TopicWhereUniqueInput!]
  connectOrCreate: [TopicCreateOrConnectWithoutDocumentsInput!]
  create: [TopicCreateWithoutDocumentsInput!]
  delete: [TopicWhereUniqueInput!]
  deleteMany: [TopicScalarWhereInput!]
  disconnect: [TopicWhereUniqueInput!]
  set: [TopicWhereUniqueInput!]
  update: [TopicUpdateWithWhereUniqueWithoutDocumentsInput!]
  updateMany: [TopicUpdateManyWithWhereWithoutDocumentsInput!]
  upsert: [TopicUpsertWithWhereUniqueWithoutDocumentsInput!]
}

input TopicUpdateWithWhereUniqueWithoutDocumentsInput {
  data: TopicUpdateWithoutDocumentsInput!
  where: TopicWhereUniqueInput!
}

input TopicUpdateWithoutDocumentsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TopicUpsertWithWhereUniqueWithoutDocumentsInput {
  create: TopicCreateWithoutDocumentsInput!
  update: TopicUpdateWithoutDocumentsInput!
  where: TopicWhereUniqueInput!
}

input TopicWhereInput {
  AND: [TopicWhereInput!]
  NOT: [TopicWhereInput!]
  OR: [TopicWhereInput!]
  documents: DocumentListRelationFilter
  id: StringFilter
  name: StringFilter
}

input TopicWhereUniqueInput {
  id: String
  name: String
}

type User {
  email: String!
  id: String!
  name: String
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  id: Int!
  name: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserCreateInput {
  email: String!
  id: String
  name: String
}

input UserCreateManyInput {
  email: String!
  id: String
  name: String
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  email: String!
  id: String!
  name: String
}

type UserMaxAggregate {
  email: String
  id: String
  name: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

type UserMinAggregate {
  email: String
  id: String
  name: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithRelationInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

enum UserScalarFieldEnum {
  email
  id
  name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
}

input UserUpdateInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  id: StringFilter
  name: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
